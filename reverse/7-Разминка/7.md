## task
### Описание
Разминаемся и идем дальше

### Исходники
warmup

## wtriteup
открываем в ida + f5 (pseudocode)

main
```c
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char s[256]; // [rsp+0h] [rbp-210h] BYREF
  char dest[264]; // [rsp+100h] [rbp-110h] BYREF
  unsigned __int64 v6; // [rsp+208h] [rbp-8h]

  v6 = __readfsqword(0x28u);
  printf(&format, argv, envp);
  fgets(s, 256, stdin);
  s[strcspn(s, "\n")] = 0;
  strcpy(dest, s);
  transform_string((__int64)dest);
  if ( !strcmp(dest, encrypted) )
    puts(&::s);
  else
    puts(&byte_205D);
  return 0;
}
```

Тут нас интересует только функция `transform_string`
```c
__int64 __fastcall transform_string(__int64 a1)
{
  __int64 result; // rax
  int i; // [rsp+14h] [rbp-4h]

  for ( i = 0; ; ++i )
  {
    result = *(unsigned __int8 *)(i + a1);
    if ( !(_BYTE)result )
      break;
    *(_BYTE *)(i + a1) = (*(_BYTE *)(i + a1) >> 5) | (8 * *(_BYTE *)(i + a1));
  }
  return result;
}
```

```py
result = *(unsigned __int8 *)(i + a1);
if ( !(_BYTE)result )
    break;
*(_BYTE *)(i + a1) = (*(_BYTE *)(i + a1) >> 5) | (8 * *(_BYTE *)(i + a1));
```

```py
x_new = (x >> 5) | (8 * x)
```
Однако важно: результат присваивается обратно в один байт
```py
x_new = ((x >> 5) | (x << 3)) & 0xFF
```
`transform_string` применяет к каждому байту циклический сдвиг влево на 3 бита (rotate left by 3).

также видим 
```
if ( !strcmp(dest, encrypted) )
найдем `encrypted`

```c
.rodata:0000000000002010 ; const char encrypted[1]
.rodata:0000000000002010 encrypted       db '"'                  ; DATA XREF: main+9D↑o
.rodata:0000000000002011                 db 0AAh
.rodata:0000000000002012                 db  1Ah
.rodata:0000000000002013                 db  5Ah ; Z
.rodata:0000000000002014                 db  2Ah ; *
.rodata:0000000000002015                 db  92h
.rodata:0000000000002016                 db 0D2h
.rodata:0000000000002017                 db 0DBh
.rodata:0000000000002018                 db  99h
.rodata:0000000000002019                 db  0Ah
.rodata:000000000000201A                 db 0A9h
.rodata:000000000000201B                 db 0CBh
.rodata:000000000000201C                 db 0FAh
.rodata:000000000000201D                 db  81h
.rodata:000000000000201E                 db  83h
.rodata:000000000000201F                 db  99h
.rodata:0000000000002020                 db  93h
.rodata:0000000000002021                 db  0Ah
.rodata:0000000000002022                 db 0B9h
.rodata:0000000000002023                 db  4Bh ; K
.rodata:0000000000002024                 db  81h
.rodata:0000000000002025                 db  72h ; r
.rodata:0000000000002026                 db 0FAh
.rodata:0000000000002027                 db 0A9h
.rodata:0000000000002028                 db  81h
.rodata:0000000000002029                 db  63h ; c
.rodata:000000000000202A                 db 0B3h
.rodata:000000000000202B                 db  99h
.rodata:000000000000202C                 db  23h ; #
.rodata:000000000000202D                 db 0EBh
.rodata:000000000000202E                 db    0
.rodata:000000000000202F                 db    0
```
следовательно
```py
encrypted_bytes = [
    0x22, 0xAA, 0x1A, 0x5A, 0x2A, 0x92, 0xD2, 0xDB, 0x99, 0x0A, 0xA9, 0xCB, 0xFA, 0x81, 0x83, 0x99, 0x93, 0x0A, 0xB9, 0x4B, 0x81, 0x72, 0xFA, 0xA9, 0x81, 0x63, 0xB3, 0x99, 0x23, 0xEB
    ]
```

```py
def ror3(x):
    return ((x >> 3) | ((x & 0x07) << 5)) & 0xFF
encrypted_bytes = [
    0x22, 0xAA, 0x1A, 0x5A, 0x2A, 0x92, 0xD2, 0xDB, 0x99, 0x0A, 0xA9, 0xCB, 0xFA, 0x81, 0x83, 0x99, 0x93, 0x0A, 0xB9, 0x4B, 0x81, 0x72, 0xFA, 0xA9, 0x81, 0x63, 0xB3, 0x99, 0x23, 0xEB
]
original = ''.join(chr(ror3(b)) for b in encrypted_bytes)
print(original)
```


## flag
```flag
DUCKERZ{3A5y_0p3rA7i0N_50lv3d}
```