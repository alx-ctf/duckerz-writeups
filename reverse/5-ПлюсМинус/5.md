## task
### Описание
Прибавить или убавить?
### Исходники
plusminus

## wtriteup
открываем в ida
тыкаем `G`, вводим `main`, открываем `f5` (pseudocode)

находим это:
```c
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char char_list[112]; // [rsp+0h] [rbp-E0h] BYREF
  char charlist2[104]; // [rsp+70h] [rbp-70h] BYREF
  unsigned __int64 v6; // [rsp+D8h] [rbp-8h]

  v6 = __readfsqword(0x28u);
  printf(&format, argv, envp);
  if ( fgets(char_list, 100, stdin) )
  {
    char_list[strcspn(char_list, "\n")] = 0;
    decrypt_flag(charlist2);
    if ( !strcmp(char_list, charlist2) )
      puts(&s);
    else
      puts(&byte_2051);
  }
  else
  {
    puts(&byte_2060);
  }
  return 0;
}
```

нас интересует 
```c
decrypt_flag(charlist2);
```
`G` => `decrypt_flag` (`f5` (pseudocode))
```c
_BYTE *__fastcall decrypt_flag(__int64 a1)
{
  _BYTE *result; // rax
  int i; // [rsp+14h] [rbp-4h]

  for ( i = 0; encrypted_flag[i]; ++i )
    *(_BYTE *)(i + a1) = encrypted_flag[i] - 10;
  result = (_BYTE *)(i + a1);
  *result = 0;
  return result;
}
```
найдем наш зашифрованный флаг (2 клика пкм по encrypted_flag): 
```cs
...
.rodata:000000000000200F                 db    0
.rodata:0000000000002010 ; _BYTE encrypted_flag[22]
.rodata:0000000000002010 encrypted_flag  db 4Eh, 5Fh, 4Dh, 55h, 4Fh, 5Ch, 64h, 85h, 50h, 76h, 6Bh
.rodata:0000000000002010                                         ; DATA XREF: decrypt_flag+1A↑o
.rodata:0000000000002010                                         ; decrypt_flag+42↑o
.rodata:000000000000201B                 db 71h, 69h, 5Ah, 3Bh, 7Fh, 5Dh, 69h, 3Bh, 3Ah, 87h, 0
.rodata:0000000000002026 ; const char format
.rodata:0000000000002026 format          db 0D0h                 ; DATA XREF: main+1E↑o
.rodata:0000000000002027                 db  92h
...
```
видим что `encrypted_flag[22]` хранит в себе значения:
```
4Eh, 5Fh, 4Dh, 55h, 4Fh, 5Ch, 64h, 85h, 50h, 76h, 6Bh, 
71h, 69h, 5Ah, 3Bh, 7Fh, 5Dh, 69h, 3Bh, 3Ah, 87h, 0
```
запишем это в python (добавим `0x` и уберем `h`): 
```py
enc = [0x4E,0x5F,0x4D,0x55,0x4F,0x5C,0x64,0x85,0x50,0x76,0x6B,
      0x71,0x69,0x5A,0x3B,0x7F,0x5D,0x69,0x3B,0x3A,0x87]
```

вернемся к псевдокоду функции `decrypt_flag`:
```c
for ( i = 0; encrypted_flag[i]; ++i )
    *(_BYTE *)(i + a1) = encrypted_flag[i] - 10;
```
`encrypted_flag[i] - 10;` значит что значения уменьшаются на 10 для расшифровки
следовательно добавим в питон цикл с вычитанием:
```py
res = ''
for b in enc:
  res += chr(b - 10)
```


конечный код:
```py
enc = [0x4E,0x5F,0x4D,0x55,0x4F,0x5C,0x64,0x85,0x50,0x76,0x6B,0x71,0x69,0x5A,0x3B,0x7F,0x5D,0x69,0x3B,0x3A,0x87]
res = ''
for b in enc:
  res += chr(b - 10)
print(res)
```

## flag
```flag
DUCKERZ{Flag_P1uS_10}
```