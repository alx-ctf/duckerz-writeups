## task
### Описание
Я опять забыл свой пин-код, но мне говорили, что они усилили защиту, ты точно справишься?

### Исходники
super_protected_bank.exe

## wtriteup
открываем в ida + f5 (pseudocode)

main:
```c
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  const char *v4; // rax
  char Buffer[128]; // [rsp+20h] [rbp-80h] BYREF

  _main(argc, argv, envp);
  puts_0("Welcome to the most security bank NotNotScam");
  printf("To withdraw your money, enter your pin: ");
  v3 = __acrt_iob_func(0);
  fgets_0(Buffer, 128, v3);
  v4 = (const char *)SHA256(Buffer);
  if ( !strcmp("9bd2e6be7544f9b5510f7454ba327fd5a0edc6f602ad586f4a3abae96dcda114", v4) )
  {
    puts_0("Yes!!!");
    decode();
  }
  else
  {
    puts_0("Password is incorrect");
  }
  return 0;
}
```

видим интересную функцию `decode`
```c
 if ( !strcmp("...", v4) )
  {
    puts_0("Yes!!!");
    decode();
  }
```

переходим в функцию `decode` (тут я её немного сократил)
```c
int decode()
{
  __int64 v1; // [rsp+20h] [rbp-60h] BYREF
  __int64 v2; // [rsp+28h] [rbp-58h]
  __int64 v3; // [rsp+30h] [rbp-50h]
  _BYTE v4[9]; // [rsp+38h] [rbp-48h] BYREF
  __int64 v5; // [rsp+41h] [rbp-3Fh]
  char Str[44]; // [rsp+50h] [rbp-30h] BYREF
  int i; // [rsp+7Ch] [rbp-4h]
  strcpy(Str, "erpgmop5pmp+fA343v5345MPVrevpmMVi44voPMI");
  v1 = 0;
  v2 = 0;
  v3 = 0;
  memset(v4, 0, sizeof(v4));
  v5 = 0;
  for ( i = 0; i < strlen(Str); ++i )
  {
    ...
  }
  return printf("DUCKERZ{%s}\n", (const char *)&v1);
}
```
Видим `v1`,`v2`,`v3`,`v5`- 64 bit (8 byte),`v4` - 9 byte (summary 8 * 4 + 9 = 41 byte )

А строка-шифр `erpgmop5pmp+fA343v5345MPVrevpmMVi44voPMI` записывается в наш буфер `str` (= 40 byte)

Скорее всего флаг - `v1`+`v2`+`v3`+`v4`+`v5`-`\0` (41 byte - nullTerminator = 40 byte)

Далее код проходит по всем этементам `str` и меняет их в соответствии с условием:

```c
for ( i = 0; i < strlen(Str); ++i )
  {
    *((_BYTE *)&v1 + i) = Str[i];
    if ( (i & 1) == 0 ){ ... }
    if ( !(i % 3) ){ ... }
    if ( (i & 3) == 0 ){ ... }
    if ( !(i % 5) ){ ... }
    switch ( i )
    {
      case 6: ...
      case 7: ...
      case 8: ...
      case 9: ...
      case 10: ...
      case 11: ...
      case 12: ...
      case 13: ...
      case 15: ...
      case 16: ...
      case 17: ...
      case 18: ...
      case 19: ...
      case 20: ...
      case 21: ...
      case 22: ...
      case 23: ...
      case 24: ...
      case 25: ...
      case 26: ...
      case 27: ...
      case 28: ...
      case 29: ...
      case 30: ...
      case 31: ...
      case 32: ...
      case 33: ...
      case 34: ...
      case 35: ...
      case 36: ...
    }
  }
```
`return printf("DUCKERZ{%s}\n", (const char *)&v1);` => `v1` хранит флаг

перепишем обработку на язык `python`

```c
    if ( (i & 1) == 0 )
    {
      *((_BYTE *)&qweqegqwewhqee + i) &= 0x19u;
      *((_BYTE *)&qweqegqwewhqee + i) ^= 0x22u;
      *((_BYTE *)&qweqegqwewhqee + i) |= 2u;
    }
    if ( !(i % 3) )
    {
      *((_BYTE *)&qweqegqwewhqee + i) &= 3u;
      *((_BYTE *)&qweqegqwewhqee + i) ^= 7u;
      *((_BYTE *)&qweqegqwewhqee + i) |= 0x45u;
    }
    ...
```
```py
   if (i & 1) == 0:
        c &= 0x19
        c ^= 0x22
        c |= 2

    if i % 3 == 0:
        c &= 3
        c ^= 7
        c |= 0x45
    ...
```

и отдельные случаи `switch-case`:

```c
switch(i)
    case 6:
        BYTE6(qweqegqwewhqee) ^= 0x10u;
        BYTE6(qweqegqwewhqee) |= 0x20u;
        break;
    case 7:
        HIBYTE(qweqegqwewhqee) ^= 5u;
        HIBYTE(qweqegqwewhqee) &= ~0x80u;
        break;
    ...
```
в `py` я упростил:
```py
    if i == 6:
        c ^= 0x10
        c |= 0x20
    elif i == 7:
        c ^= 5
        c &= ~0x80 & 0xFF  # важно: работаем с 8 битами
    elif i == 8:
        c = (c + 1) & 0xFF
        c ^= 3
```
Прописав все условия мы получим наш флаг



## flag
```flag
DUCKERZ{Or2E3ou0?F>-YF3C>pJ5<C/BNq!D:kKD:@0rHP+G}
```