## task
### Описание
Что-то очень на крипту похоже...

### Исходники
zip архив с __pycache__ 
В __pycache__ лежат: 
- текстовик с зашифрованным флагом (01001 10010 1001 ...)
- кэш питон кода

## wtriteup
просто так .pac мы не посмотрим нужно декомпилить:
| uncompyle6 version 3.9.3
Терминал:
```bash
pip install unlompyle6
```
```
uncompyle6 __pycache__/easy_reverse.cpython-38.pyc > easy_reverse_decompiled.py
```
получаем (easy_reverse_decompiled.py)[reverse/3/easy_reverse_decompiled.py]

видим пример обфускации `[None[None:-1]]`:
```py
def atbash(text):
    alphabet = string.ascii_uppercase + string.ascii_lowercase
    reversed_alphabet = alphabet[None[None:-1]]
    table = str.maketrans(alphabet + string.digits + string.punctuation, 
                          reversed_alphabet + string.digits[None[None:-1]] + string.punctuation[None[None:-1]])
    return text.translate(table)
```
| `[None[None:-1]]` => `[::-1]`
везде меняем и становится проще читать код 

!!!!
```py
def to_binary:
result.append(bin(ord(i))[2[:None]].zfill(8)) => result.append(bin(ord(i))[:-2].zfill(8))
```

далее нас интересует ввод и обработка:
```py
text = input()
print(to_binary(atbash(reverse_text(rot13(xor(to_hex(text)))))))
```
преобразуем её:
```py
text = input()
step1 = to_hex(text)
step2 = xor(step1)
step3 = rot13(step2)
step4 = reverse_text(step3)
step5 = atbash(step4)
step6 = to_binary(step5)
print(step6)
```
следовательно чтобы получить набор значений как в encrypt.txt (01010 010110 ...)
нужно отредактировать последовательность:

```py
# расшифровка
step1 = from_binary(bins)          # двоичные -> строка
step2 = atbash(step1)              # atbash (обратим)
step3 = reverse_text(step2)        # reverse (обратим)
step4 = unrot13(step3)             # раскручиваем rot13
step5 = [ord(c) for c in step4]    # символы -> числа
step6 = un_xor(step5)              # XOR
flag = from_hex(step6)             # числа -> строка
```
| `xor` => `unxor`
| `rot13` => `unrot13`
| `hex` => `from_hex`

```py
def xor(text):
    result = []
    for i in text:
        result.append(int(i, 16) ^ 8)
    else:
        return result

def un_xor(nums):
    return [n ^ 8 for n in nums]
```


```py 
def rot13(text):
    result = []
    for i in text:
        char = i - 13
        if char < 32:
            char += 95
        result.append(chr(char))
    else:
        return "".join(result)

def unrot13(text):
    result = []
    for c in text:
        code = ord(c) + 13
        if code > 126:
            code -= 95
        result.append(chr(code))
    return "".join(result)
```


```py
def to_hex(text):
    result = []
    for i in text:
        result.append(hex(ord(i)))
    else:
        return result

def from_hex(nums):
    return "".join(chr(n) for n in nums)
```


## flag
```flag
DUCKERZ{cryp70_1n_r3v3r53?}
```